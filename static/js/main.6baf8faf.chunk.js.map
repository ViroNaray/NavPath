{"version":3,"sources":["Components/Node.jsx","Components/GridKey.jsx","Components/Buttons.jsx","Algorithms/CommonFunctions.js","Algorithms/BFSandDFS.js","Algorithms/Dijkstra.js","Algorithms/AStar.js","Components/Grid.jsx","Components/Introduction.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isWall","isWeighted","isHome","isDest","isDiscovered","onMouseDown","onMouseEnter","extraClass","discoveredClass","id","className","Component","GridKey","HeaderButton","onClick","click","text","ClearButton","useState","open","setOpen","onMouseLeave","style","outline","path","walls","title","weights","all","ToggleButton","setWall","Buttons","showBFS","showDFS","showDijkstra","showAStar","clearPath","clearWalls","clearWeights","clearAll","toggleClick","backgroundColor","top","paddingBottom","initDiscoveredGrid","grid","discoveredMap","i","length","arr","j","push","initTotalWeightGridWithInfinity","totalWeights","Infinity","PriorityQueue","data","weight","fixUp","pop","fixDown","n","parentIndex","Math","ceil","temp","min","addNeighbors","deque","node","destCoords","parentNode","Coordinate","traditionalSolve","homeCoords","useBFS","nodesVisitedInOrder","nextNode","shift","addNodeToPQ","pq","parent","prospectiveWeight","dijkstraSolve","origGrid","slice","empty","closestNode","getWeightHeuristic","dy","dx","sqrt","aStarSolve","Grid","state","weightMultiplier","mouseIsPressed","clickSettingOn","clickSettingIsWall","movingEndpoints","movingHome","isSolving","isSolved","initGrid","getStarterGrid","setState","newClickSetting","updatedGrid","toggleNodeType","coords","changeEndpointLocation","pathfindingMethod","nodesDiscoveredInOrder","clearGrid","document","getElementById","display","gridWithParentsDijkstra","gridWithParentsAStar","animate","setTimeout","classList","add","animatePath","destinationNode","reversePath","currNode","backtrackPath","type","clearedGrid","findPath","color","marginBottom","zIndex","handleMouseUp","onMouseUp","map","nodeIdx","handleMouseDown","handleMouseEnter","numRows","numCols","nodeRow","constructNode","oldGrid","newGrid","visitedNodes","querySelectorAll","forEach","call","el","remove","pathNodes","Introduction","isActive","setActive","data-dismiss","aria-label","aria-hidden","href","target","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6baf8faf.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport './Styles/Node.css';\n\nclass Node extends Component {\n    render() {\n        const {\n            row,\n            col,\n            isWall,\n            isWeighted,\n            isHome,\n            isDest,\n            isDiscovered,\n            onMouseDown,\n            onMouseEnter,\n            //onMouseUp\n        } = this.props;\n\n        const extraClass = isWall ? \"node-wall\" :\n            isWeighted ? \"node-weight\" :\n                isHome ? \"node-home\" :\n                    isDest ? \"node-dest\" :\n                        \"\";\n\n        const discoveredClass = isDiscovered ? \"node-discovered\" : \"\";\n\n        return (\n            <div\n                id={`node-${row}-${col}`}\n                className={`node ${extraClass} ${discoveredClass}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n            // onMouseUp={() => onMouseUp()}\n            ></div>\n        );\n    }\n}\n\n\nexport default Node;\n","import React from 'react';\nimport './Styles/GridKey.css';\n\n\nfunction GridKey() {\n    return (\n        <div className=\"grid-key\">\n            <div className=\"key-entry\">\n                <div className=\"square home\" />\n                <div className=\"text\">Home</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square destination\" />\n                <div className=\"text\">Destination</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square weight\" />\n                <div className=\"text\">Weighted Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square wall\" />\n                <div className=\"text\">Wall</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square undiscovered\" />\n                <div className=\"text\">Undiscovered Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square discovered\" />\n                <div className=\"text\">Discovered Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square path\" />\n                <div className=\"text\">Path Node</div>\n            </div>\n        </div>\n    );\n}\n\n\nexport default GridKey;\n","import React, { Component, useState } from 'react';\nimport GridKey from './GridKey';\nimport './Styles/Buttons.css';\n\n\nfunction HeaderButton(props) {\n    return (\n        <button className=\"solve-button\" onClick={props.click}>\n            {props.text}\n        </button>\n    );\n}\n\n\nfunction ClearButton(props) {\n    const [open, setOpen] = useState(false);\n\n    return (\n        <div className=\"dropdown-container\" onMouseLeave={() => setOpen(false)}>\n            <button className=\"solve-button clear-button\" style={{ outline: 'none' }} onMouseEnter={() => setOpen(true)} /*{onClick={props.click}}*/>\n                Clear\n            </button>\n            {open && (\n                <div className=\"dropdown\">\n                    <ul className=\"dropdown-ul\">\n                        <li className=\"dropdown-li\" onClick={props.path} >Clear Path</li>\n                        <li className=\"dropdown-li\" onClick={props.walls} title=\"This will also clear the path\">Clear Walls</li>\n                        <li className=\"dropdown-li\" onClick={props.weights} title=\"This will also clear the path\">Clear Weights</li>\n                        <li className=\"dropdown-li\" onClick={props.all} >Clear All</li>\n                    </ul>\n                </div>\n            )}\n        </div>\n    );\n}\n\n\nfunction ToggleButton({ click }) {\n    const [isWall, setWall] = useState(true);\n\n    const toggle = () => {\n        setWall(!isWall);\n        click();\n    }\n\n    return (\n        <div className=\"toggle-container\">\n            <div className=\"toggle-bar\" onClick={toggle}>\n                <div className={`dialog-button ${isWall ? \"\" : \"disabled\"}`}>\n                    {isWall ? \"Walls\" : \"Weights\"}\n                </div>\n            </div>\n        </div>\n    );\n}\n\n\nclass Buttons extends Component {\n\n    render() {\n        const {\n            showBFS,\n            showDFS,\n            showDijkstra,\n            showAStar,\n\n            clearPath,\n            clearWalls,\n            clearWeights,\n            clearAll,\n\n            toggleClick\n        } = this.props;\n\n        return (\n            <div className=\"header\">\n                <div style={{ backgroundColor: '#557A95', top: '0' }}>\n                    <h1 className=\"header-title\">NavPath</h1>\n\n                    <div style={{ paddingBottom: '1vw' }}>\n                        <HeaderButton click={showBFS} text=\"BFS\" />\n                        <HeaderButton click={showDFS} text=\"DFS\" />\n                        <HeaderButton click={showDijkstra} text=\"Dijkstra's\" />\n                        <HeaderButton click={showAStar} text=\"A*\" />\n\n                        <ClearButton path={clearPath} walls={clearWalls} weights={clearWeights} all={clearAll} />\n\n                        <ToggleButton click={toggleClick} />\n                    </div>\n                </div>\n\n                <GridKey />\n            </div >\n        );\n    }\n}\n\nexport default Buttons;\n","// Common functions used by multiple algorithms\n\nfunction backtrackPath(destinationNode) {\n    const reversePath = [];\n\n    let currNode = destinationNode;\n\n    while (currNode != null) {\n        reversePath.push(currNode);\n        currNode = currNode.parentNode;\n    }\n\n    return reversePath;\n}\n\n\nfunction initDiscoveredGrid(grid) {\n    // Create a grid indicating all nodes are undiscovered\n    const discoveredMap = [];\n    for (let i = 0; i < grid.length; i++) {\n        const arr = [];\n        for (let j = 0; j < grid[i].length; j++) {\n            arr.push(false);\n        }\n\n        discoveredMap.push(arr);\n    }\n\n    return discoveredMap;\n}\n\n\nfunction initTotalWeightGridWithInfinity(grid) {\n    const totalWeights = [];\n\n    for (let i = 0; i < grid.length; i++) {\n        const arr = [];\n        for (let j = 0; j < grid[i].length; j++) {\n            arr.push(Infinity);\n        }\n\n        totalWeights.push(arr);\n    }\n\n    return totalWeights;\n}\n\n// This is a Priority Queue that utilizes a Min Heap\nclass PriorityQueue {\n    // data's elements have the structure of [weight, row, col]\n    constructor(/*grid*/) {\n        this.data = [];\n\n\n        /*for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                this.data.push(new QueueNode(Infinity, i, j));\n            }\n        }*/\n\n        // Heapsort - not needed for dijkstra's\n        /*for (let i = Math.ceil(this.data.length / 2) - 1; i >= 0; i--) {\n            this.fixDown(i);\n        }*/\n    }\n\n\n    empty() {\n        return this.data.length === 0;\n    }\n\n\n    top() {\n        return this.data[0];\n    }\n\n\n    push(row, col, weight) {\n        this.data.push(new Node(row, col, weight));\n        this.fixUp(this.data.length - 1);\n    }\n\n\n    pop() {\n        this.data[0] = this.data[this.data.length - 1];\n        this.data.pop();\n        this.fixDown(0);\n    }\n\n\n    // Private method\n    fixUp(n) {\n        // if (n === 0)\n        //     return;\n\n        let parentIndex = Math.ceil(n / 2) - 1;\n\n        ////// This is a recursive definition\n        // if (this.data[n].weight < this.data[parentIndex].weight) {\n        //     const temp = this.data[n];\n        //     this.data[n] = this.data[parentIndex];\n        //     this.data[parentIndex] = temp;\n\n        //     return this.fixUp(parentIndex);\n        // }\n        // else\n        //     return;\n\n        // Iterative definition\n        while (n !== 0 && this.data[n].weight < this.data[parentIndex].weight) {\n            const temp = this.data[n];\n            this.data[n] = this.data[parentIndex];\n            this.data[parentIndex] = temp;\n\n            n = parentIndex;\n            parentIndex = Math.ceil(n / 2) - 1;\n        }\n    }\n\n\n    // Private method\n    fixDown(n) {\n        if ((2 * n) + 1 >= this.data.length)\n            return;\n\n        // If the node has 2 children and must be rearranged\n        if ((2 * n) + 2 < this.data.length && this.data[n].weight >\n            Math.min(this.data[(2 * n) + 1].weight, this.data[(2 * n) + 2].weight)) {\n\n            const temp = this.data[n];\n\n            if (this.data[(2 * n) + 1].weight < this.data[(2 * n) + 2].weight) {\n                this.data[n] = this.data[(2 * n) + 1];\n                this.data[(2 * n) + 1] = temp;\n\n                return this.fixDown((2 * n) + 1);\n            }\n            else {\n                this.data[n] = this.data[(2 * n) + 2];\n                this.data[(2 * n) + 2] = temp;\n\n                return this.fixDown((2 * n) + 2);\n            }\n        }\n        // If the node only has 1 child and must be rearranged\n        else if ((2 * n) + 1 < this.data.length &&\n            this.data[n].weight > this.data[(2 * n) + 1].weight) {\n\n            const temp = this.data[n];\n            this.data[n] = this.data[(2 * n) + 1];\n            this.data[(2 * n) + 1] = temp;\n\n            return this.fixDown((2 * n) + 1);\n        }\n    }\n\n}\n\nclass Node {\n    constructor(row, col, weight) {\n        this.row = row;\n        this.col = col;\n        this.weight = weight;\n    }\n}\n\n\n\n\n\n\nexport { backtrackPath, initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue };\n\n","import { initDiscoveredGrid } from './CommonFunctions';\n\n// Determins the path between the 2 points using either BFS or DFS\n\nfunction traditionalSolve(grid, homeCoords, destCoords, useBFS) {\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap and set the Home Point as discovered\n    const discoveredMap = initDiscoveredGrid(grid);\n    discoveredMap[homeCoords[0]][homeCoords[1]] = true;\n\n    // Create dequeue and add the Home Node\n    const deque = [];\n    deque.push(new Coordinate(homeCoords[0], homeCoords[1])); // Row, Col\n\n    // Continue while there are still nodes in the deque\n    while (deque.length !== 0) {\n        let nextNode;\n\n        // Get the next node based on BFS/DFS\n        if (useBFS) // Using a queue structure\n            nextNode = deque.shift();\n        else // Using a stack structure\n            nextNode = deque.pop();\n\n        nodesVisitedInOrder.push(nextNode);\n\n        // We do not need to check since the algorithm stops when the destination is a neighbor\n        // // Check if this is the destination\n        // if (nextNode.row === destCoords[0] && nextNode.col === destCoords[1])\n        //     break;\n\n        if (addNeighbors(grid, deque, nextNode, discoveredMap, destCoords)) {\n            nodesVisitedInOrder.push(new Coordinate(destCoords[0], destCoords[1]));\n            break;\n        }\n    }\n\n    return nodesVisitedInOrder;\n}\n\n\n// Returns true if the destination has been found\nfunction addNeighbors(grid, deque, node, discoveredMap, destCoords) {\n    // Add to the deque if it is within the bounds, has not been discovered, and is not a wall\n\n    // Right\n    if (node.col < grid[0].length - 1 && !discoveredMap[node.row][node.col + 1] && !grid[node.row][node.col + 1].isWall) {\n        grid[node.row][node.col + 1].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row][node.col + 1] = true;\n\n        if (node.row === destCoords[0] && node.col + 1 === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row, node.col + 1));\n        //pq.push(node.row, node.col + 1, grid[node.row][node.col + 1].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Above\n    if (node.row > 0 && !discoveredMap[node.row - 1][node.col] && !grid[node.row - 1][node.col].isWall) {\n        grid[node.row - 1][node.col].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row - 1][node.col] = true;\n\n        if (node.row - 1 === destCoords[0] && node.col === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row - 1, node.col));\n        //pq.push(node.row - 1, node.col, grid[node.row - 1][node.col].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Left\n    if (node.col > 0 && !discoveredMap[node.row][node.col - 1] && !grid[node.row][node.col - 1].isWall) {\n        grid[node.row][node.col - 1].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row][node.col - 1] = true;\n\n        if (node.row === destCoords[0] && node.col - 1 === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row, node.col - 1));\n        //pq.push(node.row, node.col - 1, grid[node.row][node.col - 1].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Below\n    if (node.row < grid.length - 1 && !discoveredMap[node.row + 1][node.col] && !grid[node.row + 1][node.col].isWall) {\n        grid[node.row + 1][node.col].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row + 1][node.col] = true;\n\n        if (node.row + 1 === destCoords[0] && node.col === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row + 1, node.col));\n        //pq.push(node.row + 1, node.col, grid[node.row + 1][node.col].weight + node.weight, [node.row, node.col]);\n    }\n\n    return false;\n\n}\n\n\nclass Coordinate {\n    constructor(row, col) {\n        this.row = row;\n        this.col = col;\n    }\n}\n\n\n\nexport default traditionalSolve;\n","import { initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue } from './CommonFunctions';\n\n// Determines the shortest path using Djikstra's algorithm\n\n// homeCoords and destCoords are in the format of [row, col]\nfunction dijkstraSolve(origGrid, homeCoords, destCoords) {\n    const grid = origGrid.slice();\n\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap\n    const discoveredMap = initDiscoveredGrid(grid);\n\n    const totalWeights = initTotalWeightGridWithInfinity(grid);\n    totalWeights[homeCoords[0]][homeCoords[1]] = 0;\n\n    // Create PQ and add the Home Node\n    let pq = new PriorityQueue();\n    pq.push(homeCoords[0], homeCoords[1], 0); // Row, Col, Weight\n\n    // Continue while there are still nodes in the PQ\n    while (!pq.empty()) {\n        const closestNode = pq.top();\n        pq.pop();\n\n        // Mark the node as discovered - we can guarantee that there is no shorter path\n        if (!discoveredMap[closestNode.row][closestNode.col]) {\n            nodesVisitedInOrder.push(closestNode);\n            discoveredMap[closestNode.row][closestNode.col] = true;\n        }\n\n        // Check if this is the destination\n        if (closestNode.row === destCoords[0] && closestNode.col === destCoords[1])\n            break;\n\n        //addNeighbors(grid, pq, closestNode, totalWeights/*, discoveredMap*/);\n        // Add neighbors\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col + 1);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row - 1, closestNode.col);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col - 1);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row + 1, closestNode.col);\n    }\n\n    return [nodesVisitedInOrder, grid];\n}\n\n\nfunction addNodeToPQ(grid, totalWeights, pq, parent, row, col) {\n    // Return if out of bounds or is a wall\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length || grid[row][col].isWall)\n        return;\n\n    const prospectiveWeight = totalWeights[parent.row][parent.col] + grid[row][col].weight;\n    // Update if the prospective weight is better than our current weight\n    if (prospectiveWeight < totalWeights[row][col]) {\n        pq.push(row, col, prospectiveWeight);\n\n        totalWeights[row][col] = prospectiveWeight;\n        grid[row][col].parentNode = grid[parent.row][parent.col];\n    }\n}\n\n\n\nexport default dijkstraSolve;\n\n\n","import { initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue } from './CommonFunctions';\n\n// Determines the shortest path using the A-Star algorithm\n\n// homeCoords and destCoords are in the format of [row, col]\nfunction aStarSolve(origGrid, homeCoords, destCoords) {\n    const grid = origGrid.slice();\n\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap\n    const discoveredMap = initDiscoveredGrid(grid);\n\n    const totalWeights = initTotalWeightGridWithInfinity(grid);\n    totalWeights[homeCoords[0]][homeCoords[1]] = getWeightHeuristic(homeCoords[0], homeCoords[1], destCoords);\n\n    // Create PQ and add the Home Node\n    let pq = new PriorityQueue();\n    pq.push(homeCoords[0], homeCoords[1], getWeightHeuristic(homeCoords[0], homeCoords[1], destCoords)); // Row, Col, Weight\n\n    // Continue while there are still nodes in the PQ\n    while (!pq.empty()) {\n        const closestNode = pq.top();\n        pq.pop();\n\n        // Mark the node as discovered - we can guarantee that there is no shorter path\n        if (!discoveredMap[closestNode.row][closestNode.col]) {\n            nodesVisitedInOrder.push(closestNode);\n            discoveredMap[closestNode.row][closestNode.col] = true;\n        }\n\n        // Check if this is the destination\n        if (closestNode.row === destCoords[0] && closestNode.col === destCoords[1])\n            break;\n\n        //addNeighbors(grid, pq, closestNode, totalWeights/*, discoveredMap*/);\n        // Add neighbors\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col + 1, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row - 1, closestNode.col, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col - 1, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row + 1, closestNode.col, destCoords);\n    }\n\n    return [nodesVisitedInOrder, grid];\n}\n\n\nfunction addNodeToPQ(grid, totalWeights, pq, parent, row, col, destCoords) {\n    // Return if out of bounds or is a wall\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length || grid[row][col].isWall)\n        return;\n\n    let prospectiveWeight = totalWeights[parent.row][parent.col] + grid[row][col].weight;\n    prospectiveWeight += getWeightHeuristic(row, col, destCoords) - getWeightHeuristic(parent.row, parent.col, destCoords);\n\n    // Update if the prospective weight is better than our current weight\n    if (prospectiveWeight < totalWeights[row][col]) {\n        pq.push(row, col, prospectiveWeight);\n\n        totalWeights[row][col] = prospectiveWeight;\n        grid[row][col].parentNode = grid[parent.row][parent.col];\n    }\n}\n\n\nfunction getWeightHeuristic(row, col, destCoords) {\n    //return Math.abs(row - destCoords[0]) + Math.abs(col - destCoords[1]);\n    const dy = row - destCoords[0];\n    const dx = col - destCoords[1];\n    return Math.sqrt((dx * dx) + (dy * dy));\n}\n\n\nexport default aStarSolve;\n","import React, { Component } from 'react';\nimport Node from './Node';\nimport Buttons from './Buttons';\n\nimport traditionalSolve from '../Algorithms/BFSandDFS';\nimport dijkstraSolve from '../Algorithms/Dijkstra';\nimport aStarSolve from '../Algorithms/AStar';\nimport { backtrackPath } from '../Algorithms/CommonFunctions';\nimport './Styles/Grid.css';\n\n\n// pseudo-enum\n// const PathfindingMethod = {\n//     DIJKSTRA: 1\n// };\n\n\nclass Grid extends Component {\n\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            weightMultiplier: 15,\n            mouseIsPressed: false,\n            clickSettingOn: false,\n            clickSettingIsWall: true,\n            movingEndpoints: false, // Only set on mouse down\n            movingHome: false,\n            homeCoords: [10, 10],\n            destCoords: [10, 44],\n            isSolving: false,\n            isSolved: false\n        };\n    }\n\n\n    componentDidMount() {\n        const numRows = 21;\n        const numCols = 55;\n\n        const initGrid = getStarterGrid(numRows, numCols, this.state.homeCoords, this.state.destCoords);\n        this.setState({ grid: initGrid });\n    }\n\n\n    handleMouseDown(row, col) {\n        // Return if the path is currently being solved\n        if (this.state.isSolving || this.state.isSolved)\n            return;\n\n        // Check if we are moving either the Home point or the Destination\n        if (this.state.grid[row][col].isHome) {\n            this.setState({ mouseIsPressed: true, movingEndpoints: true, movingHome: true });\n            return;\n        }\n        else if (this.state.grid[row][col].isDest) {\n            this.setState({ mouseIsPressed: true, movingEndpoints: true, movingHome: false });\n            return;\n        }\n\n        // Get the new click settings and toggle\n        // The new setting is the opposite of whatever the current click mode property is for the clicked node\n\n        //const newWallSetting = !this.state.grid[row][col].isWall;\n        let newClickSetting;\n        if (this.state.clickSettingIsWall)\n            newClickSetting = !this.state.grid[row][col].isWall;\n        else\n            newClickSetting = this.state.grid[row][col].weight === 1;\n\n\n        const updatedGrid = toggleNodeType(this.state.grid, row, col, newClickSetting, this.state.clickSettingIsWall, this.state.weightMultiplier);\n        this.setState({ grid: updatedGrid, mouseIsPressed: true, clickSettingOn: newClickSetting, movingEndpoints: false });\n    }\n\n\n    handleMouseEnter(row, col) {\n        // Ignore if we are not dragging or if the path is being solved\n        if (!this.state.mouseIsPressed || this.state.isSolving) {\n            return;\n        }\n        // Check if we are moving either the Home point or the Destination\n        else if (this.state.movingEndpoints) {\n            let coords;\n            let updatedGrid;\n\n            if (this.state.movingHome) {\n                coords = this.state.homeCoords;\n                [updatedGrid, coords] = changeEndpointLocation(this.state.grid, row, col, coords, true);\n                this.setState({ grid: updatedGrid, homeCoords: coords });\n            }\n            else {\n                coords = this.state.destCoords;\n                [updatedGrid, coords] = changeEndpointLocation(this.state.grid, row, col, coords, false);\n                this.setState({ grid: updatedGrid, destCoords: coords });\n            }\n\n            return;\n        }\n        // Make sure we don't turn an endpoint into a wall\n        else if (this.state.grid[row][col].isHome || this.state.grid[row][col].isDest) {\n            return;\n        }\n\n        const updatedGrid = toggleNodeType(this.state.grid, row, col, this.state.clickSettingOn, this.state.clickSettingIsWall, this.state.weightMultiplier);\n        this.setState({ grid: updatedGrid });\n    }\n\n\n    handleMouseUp() {\n        this.setState({ mouseIsPressed: false });\n    }\n\n    // 0 - BFS\n    // 1 - DFS\n    // 2 - Dijkstra\n    // 3 - A-Star\n    findPath(pathfindingMethod) {\n        if (this.state.isSolving)\n            return;\n\n        this.clearGrid(0);\n        this.setState({ isSolving: true });\n\n        let nodesDiscoveredInOrder;\n\n        document.getElementById('weight-warning').style.display = (pathfindingMethod <= 1) ? '' : 'none';\n\n        switch (pathfindingMethod) {\n            case 0:\n                nodesDiscoveredInOrder = traditionalSolve(this.state.grid, this.state.homeCoords, this.state.destCoords, true);\n                break;\n\n            case 1:\n                nodesDiscoveredInOrder = traditionalSolve(this.state.grid, this.state.homeCoords, this.state.destCoords, false);\n                break;\n\n            case 2:\n                let gridWithParentsDijkstra;\n                [nodesDiscoveredInOrder, gridWithParentsDijkstra] = dijkstraSolve(this.state.grid, this.state.homeCoords, this.state.destCoords);\n                this.setState({ grid: gridWithParentsDijkstra });\n                break;\n\n            case 3:\n                let gridWithParentsAStar;\n                [nodesDiscoveredInOrder, gridWithParentsAStar] = aStarSolve(this.state.grid, this.state.homeCoords, this.state.destCoords);\n                this.setState({ grid: gridWithParentsAStar });\n                break;\n\n            default:\n                return;\n        }\n\n        this.animate(nodesDiscoveredInOrder);\n\n    }\n\n    animate(nodesDiscoveredInOrder) {\n        for (let i = 0; i < nodesDiscoveredInOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesDiscoveredInOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-discovered\");\n            }, 6 * i);\n        }\n\n        setTimeout(() => {\n            this.animatePath();\n        }, 6 * nodesDiscoveredInOrder.length);\n    }\n\n    animatePath() {\n        const path = backtrackPath(this.state.grid[this.state.destCoords[0]][this.state.destCoords[1]]);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            setTimeout(() => {\n                const node = path[i];\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-path\");\n            }, 30 * (path.length - 1 - i));\n        }\n\n        setTimeout(() => {\n            this.setState({ isSolving: false, isSolved: true });\n        }, 30 * path.length);\n    }\n\n\n    // type parameter:\n    // 0 & ALWAYS - Unvisit all nodes and erase path\n    // 1 - Clear Walls\n    // 2 - Clear Weights\n    // 3 - Clear All\n    clearGrid(type) {\n        if (this.state.isSolving)\n            return;\n\n        const clearedGrid = clearGrid(this.state.grid, type);\n        this.setState({ grid: clearedGrid, isSolved: false });\n    }\n\n\n    render() {\n        const { grid } = this.state;\n\n        return (\n            <>\n                <Buttons\n                    showBFS={() => this.findPath(0)}\n                    showDFS={() => this.findPath(1)}\n                    showDijkstra={() => this.findPath(2)}\n                    showAStar={() => this.findPath(3)}\n\n                    clearPath={() => this.clearGrid(0)}\n                    clearWalls={() => this.clearGrid(1)}\n                    clearWeights={() => this.clearGrid(2)}\n                    clearAll={() => this.clearGrid(3)}\n\n                    toggleClick={() => this.setState({ clickSettingIsWall: !this.state.clickSettingIsWall })}\n                ></Buttons>\n\n                <div id=\"weight-warning\" style={{ color: 'red', display: 'none', marginBottom: '5px', zIndex: '10px' }}>This Algorithm ignores weighted nodes</div>\n\n                <div className=\"gridContainer\">\n                    <div className=\"grid\" onMouseLeave={() => this.handleMouseUp()} onMouseUp={() => this.handleMouseUp()}>\n                        {grid.map((row, col) => {\n                            return (\n                                <div className=\"row\" key={col}>\n                                    {row.map((node, nodeIdx) => {\n                                        const { row, col, isWall, weight, isHome, isDest, isDiscovered } = node;\n\n                                        return (\n                                            <Node key={nodeIdx}\n                                                row={row}\n                                                col={col}\n                                                isWall={isWall}\n                                                isWeighted={weight !== 1}\n                                                isHome={isHome}\n                                                isDest={isDest}\n                                                isDiscovered={isDiscovered}\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                            // onMouseUp={() => this.handleMouseUp()}\n                                            ></Node>\n                                        );\n                                    })}\n                                </div>\n                            );\n                        })}\n                    </div>\n                </div>\n\n            </>\n        );\n    }\n}\n\n\nconst getStarterGrid = (numRows, numCols, homeCoords, destCoords) => {\n    const grid = [];\n\n    for (let i = 0; i < numRows; i++) {\n        const nodeRow = [];\n        for (let j = 0; j < numCols; j++) {\n            nodeRow.push(constructNode(i, j, homeCoords, destCoords));\n        }\n\n        grid.push(nodeRow);\n    }\n\n    return grid;\n}\n\n\nconst constructNode = (row, col, homeCoords, destCoords) => {\n    return {\n        row,\n        col,\n        weight: 1,\n        isWall: false,\n        isHome: row === homeCoords[0] && col === homeCoords[1],\n        isDest: row === destCoords[0] && col === destCoords[1],\n        isDiscovered: false,\n        parentNode: null\n    };\n}\n\n\nconst toggleNodeType = (oldGrid, row, col, clickSettingOn, clickSettingIsWall, weightMultiplier) => {\n    const newGrid = oldGrid.slice();\n\n    if (clickSettingIsWall) {\n        newGrid[row][col].isWall = clickSettingOn;\n    }\n    else {\n        newGrid[row][col].weight = clickSettingOn ? weightMultiplier : 1;\n    }\n\n    return newGrid;\n}\n\n\nconst changeEndpointLocation = (oldGrid, row, col, coords, isHome) => {\n    // If it's not the home point, then it's the desination\n\n    const newGrid = oldGrid.slice();\n    //newGrid[coords[0]][coords[1]].isWall = false;\n\n    if (isHome) {\n        newGrid[coords[0]][coords[1]].isHome = false;\n        newGrid[row][col].isHome = true;\n    }\n    else {\n        newGrid[coords[0]][coords[1]].isDest = false;\n        newGrid[row][col].isDest = true;\n    }\n\n    return [newGrid, [row, col]];\n}\n\n\n// type parameter:\n// ALWAYS - Unvisit all nodes and erase path\n//      ALWAYS - Reset starting grid weights -- ignore\n// 1 - Clear Walls\n// 2 - Clear Weights\n// 3 - Clear All\nconst clearGrid = (oldGrid, type) => {\n    const newGrid = oldGrid.slice();\n\n    // Unvisit all nodes\n    const visitedNodes = document.querySelectorAll(\".node-discovered\");\n    [].forEach.call(visitedNodes, function (el) {\n        el.classList.remove(\"node-discovered\");\n    });\n\n    // Erase the path\n    const pathNodes = document.querySelectorAll(\".node-path\");\n    [].forEach.call(pathNodes, function (el) {\n        el.classList.remove(\"node-path\");\n    });\n\n\n\n    // Iterate through the grid\n    for (let i = 0; i < newGrid.length; i++) {\n        for (let j = 0; j < newGrid[i].length; j++) {\n\n            // Reset parents\n            newGrid[i][j].parent = null;\n\n            if (type === 1 || type === 3) // Clear walls\n                newGrid[i][j].isWall = false;\n            if (type === 2 || type === 3) // Clear Weights\n                newGrid[i][j].weight = 1;\n\n        }\n    }\n\n\n    return newGrid;\n}\n\n\n\nexport default Grid;\n","import React, { useState } from 'react';\nimport './Styles/Introduction.css';\n\nfunction Introduction() {\n    const [isActive, setActive] = useState(true);\n\n    return (\n        isActive &&\n        <div className=\"intro-container\">\n            <div>\n                <button type=\"button\" className=\"close\" data-dismiss=\"alert\" aria-label=\"Close\" onClick={() => setActive(false)}>\n                    <span aria-hidden=\"true\">&times;</span>\n                </button>\n            </div>\n            <div className=\"intro\">\n\n\n                <h1>Introduction : </h1>\n                <p> Welcome to <b>NavPath</b> by Viroshan Narayan! </p>\n                <p>Here, you can see how different pathfinding algorithms work, all with your own eyes!</p>\n                <p>Here are a few things to get you started:</p>\n\n                <div>\n                    <ol className=\"instruction-set\">\n                        <li>Click and drag the home and destination points to move them.</li>\n                        <li>Click and drag on empty nodes to make them walls or weighted nodes.<br /> This setting is determined by the toggle at the top of the page.\n                            <ul>\n                                <li>Walls cannot be passed through</li>\n                                <li>Weighted nodes are harder to move through</li>\n                                <li>Not all algorithms are affected by weights</li>\n                            </ul>\n                        </li>\n                        <li>Find the path from the home point to the destination using any of the<br /> following algorithms:\n                            <ul>\n                                <li><b>Breadth-First Search (BFS):</b> an <b>unweighted</b> algorithm that<br />&emsp; guarantees optimality</li>\n                                <li><b>Depth-First Search )DFS):</b> a very inefficient, <b>unweighted</b><br />&emsp; algorithm</li>\n                                <li><b>Dijkstra's Algorithm:</b> a <b>weighted</b> algorithm that<br />&emsp; guarantees optimality</li>\n                                <li><b>A*:</b> an improvement upon Dijkstra's Algorithm</li>\n                            </ul>\n                        </li>\n                        <li>Clear the displayed path, walls, or weights using the \"Clear\" dropdown<br />&emsp; at the top of the page</li>\n                    </ol>\n                </div>\n                <p>If you'd like to, you can check out the source code for this site at my <a href=\"https://www.google.com\" target=\"_blank\">github</a>.</p>\n                <p>Now that you're up to speed, <b>LET'S FIND SOME PATHS!!!</b></p>\n            </div>\n        </div>\n    );\n}\n\n\nexport default Introduction;\n","import './App.css';\n\nimport Grid from './Components/Grid';\nimport Introduction from './Components/Introduction';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Introduction />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
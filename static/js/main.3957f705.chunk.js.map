{"version":3,"sources":["Components/Node.jsx","Components/GridKey.jsx","Components/Buttons.jsx","Algorithms/CommonFunctions.js","Algorithms/BFSandDFS.js","Algorithms/Dijkstra.js","Algorithms/AStar.js","Components/Grid.jsx","Components/Introduction.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","row","col","isWall","isWeighted","isHome","isDest","onMouseDown","onMouseEnter","extraClass","endpointClass","id","className","Component","GridKey","HeaderButton","onClick","click","text","ClearButton","useState","open","setOpen","onMouseLeave","style","outline","path","walls","title","weights","all","ToggleButton","setWall","Buttons","openIntro","showBFS","showDFS","showDijkstra","showAStar","clearPath","clearWalls","clearWeights","clearAll","toggleClick","backgroundColor","top","paddingBottom","backtrackPath","destinationNode","reversePath","parentNode","currNode","push","initDiscoveredGrid","grid","discoveredMap","i","length","arr","j","initTotalWeightGridWithInfinity","totalWeights","Infinity","PriorityQueue","data","weight","fixUp","pop","fixDown","n","parentIndex","Math","ceil","temp","min","addNeighbors","deque","node","destCoords","Coordinate","traditionalSolve","oldGrid","homeCoords","useBFS","slice","nodesVisitedInOrder","nextNode","shift","addNodeToPQ","pq","parent","prospectiveWeight","dijkstraSolve","origGrid","empty","closestNode","getWeightHeuristic","dy","dx","sqrt","aStarSolve","Grid","state","weightMultiplier","mouseIsPressed","clickSettingOn","clickSettingIsWall","movingEndpoints","movingHome","isSolving","isSolved","lastAlgo","initGrid","getStarterGrid","setState","newClickSetting","updatedGrid","toggleNodeType","findPath","updatedCoords","changeEndpointLocation","pathfindingMethod","isRedraw","nodesDiscoveredInOrder","clearGrid","document","getElementById","visibility","gridWithParents","starterGrid","destIsWall","showRedraw","animate","setTimeout","classList","add","animatePath","showPathRedrawn","type","isButtonAction","clearedGrid","color","marginBottom","zIndex","handleMouseUp","onMouseUp","map","nodeIdx","handleMouseDown","handleMouseEnter","numRows","numCols","nodeRow","constructNode","newGrid","visitedNodes","querySelectorAll","forEach","call","el","remove","visitedNodesRedrawn","pathNodes","Introduction","closeIntro","data-dismiss","aria-label","aria-hidden","href","target","rel","App","showIntro","setIntroVisibility","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3957f705.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport './Styles/Node.css';\n\nclass Node extends Component {\n    render() {\n        const {\n            row,\n            col,\n            isWall,\n            isWeighted,\n            isHome,\n            isDest,\n            onMouseDown,\n            onMouseEnter,\n        } = this.props;\n\n        const extraClass = isWall ? \"node-wall\" :\n            isWeighted ? \"node-weight\" : \"\";\n\n        const endpointClass = isHome ? \"node-home\" :\n            isDest ? \"node-dest\" : \"\";\n\n\n        return (\n            <div\n                id={`node-${row}-${col}`}\n                className={`node ${extraClass} ${endpointClass}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n            ></div>\n        );\n    }\n}\n\n\nexport default Node;\n","import React from 'react';\nimport './Styles/GridKey.css';\n\n\nfunction GridKey() {\n    return (\n        <div className=\"grid-key\">\n            <div className=\"key-entry\">\n                <div className=\"square home\" />\n                <div className=\"text\">Home</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square destination\" />\n                <div className=\"text\">Destination</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square weight\" />\n                <div className=\"text\">Weighted Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square wall\" />\n                <div className=\"text\">Wall</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square undiscovered\" />\n                <div className=\"text\">Undiscovered Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square discovered\" />\n                <div className=\"text\">Discovered Node</div>\n            </div>\n            <div className=\"key-entry\">\n                <div className=\"square path\" />\n                <div className=\"text\">Path Node</div>\n            </div>\n        </div>\n    );\n}\n\n\nexport default GridKey;\n","import React, { Component, useState } from 'react';\nimport GridKey from './GridKey';\nimport './Styles/Buttons.css';\n\n\nfunction HeaderButton(props) {\n    return (\n        <button className=\"solve-button\" onClick={props.click}>\n            {props.text}\n        </button>\n    );\n}\n\n\nfunction ClearButton(props) {\n    const [open, setOpen] = useState(false);\n\n    return (\n        <div className=\"dropdown-container\" onMouseLeave={() => setOpen(false)}>\n            <button className=\"solve-button clear-button\" style={{ outline: 'none' }} onMouseEnter={() => setOpen(true)} /*{onClick={props.click}}*/>\n                Clear\n            </button>\n            {open && (\n                <div className=\"dropdown\">\n                    <ul className=\"dropdown-ul\">\n                        <li className=\"dropdown-li\" onClick={props.path} >Clear Path</li>\n                        <li className=\"dropdown-li\" onClick={props.walls} title=\"This will also clear the path\">Clear Path & Walls</li>\n                        <li className=\"dropdown-li\" onClick={props.weights} title=\"This will also clear the path\">Clear Path & Weights</li>\n                        <li className=\"dropdown-li\" onClick={props.all} >Clear All</li>\n                    </ul>\n                </div>\n            )}\n        </div>\n    );\n}\n\n\nfunction ToggleButton({ click }) {\n    const [isWall, setWall] = useState(true);\n\n    const toggle = () => {\n        setWall(!isWall);\n        click();\n    }\n\n    return (\n        <div className=\"toggle-container\">\n            <div className=\"toggle-bar\" onClick={toggle}>\n                <div className={`dialog-button ${isWall ? \"\" : \"disabled\"}`}>\n                    {isWall ? \"Walls\" : \"Weights\"}\n                </div>\n            </div>\n        </div>\n    );\n}\n\n\nclass Buttons extends Component {\n\n    render() {\n        const {\n            openIntro,\n\n            showBFS,\n            showDFS,\n            showDijkstra,\n            showAStar,\n\n            clearPath,\n            clearWalls,\n            clearWeights,\n            clearAll,\n\n            toggleClick\n        } = this.props;\n\n        return (\n            <div className=\"header\">\n                <div style={{ backgroundColor: '#557A95', top: '0' }}>\n                    <h1 className=\"header-title\">\n                        NavPath\n                        <div className=\"info-pic\" onClick={openIntro} />\n                    </h1>\n\n                    <div style={{ paddingBottom: '1vw' }}>\n                        <HeaderButton click={showBFS} text=\"BFS\" />\n                        <HeaderButton click={showDFS} text=\"DFS\" />\n                        <HeaderButton click={showDijkstra} text=\"Dijkstra's\" />\n                        <HeaderButton click={showAStar} text=\"A*\" />\n\n                        <ClearButton path={clearPath} walls={clearWalls} weights={clearWeights} all={clearAll} />\n\n                        <ToggleButton click={toggleClick} />\n                    </div>\n                </div>\n\n                <GridKey />\n            </div >\n        );\n    }\n\n}\n\nexport default Buttons;\n","// Common functions used by multiple algorithms\n\nfunction backtrackPath(destinationNode) {\n    const reversePath = [];\n\n    if (destinationNode.parentNode === null)\n        return reversePath;\n\n    let currNode = destinationNode;\n\n    while (currNode != null) {\n        reversePath.push(currNode);\n        currNode = currNode.parentNode;\n    }\n\n    return reversePath;\n}\n\n\nfunction initDiscoveredGrid(grid) {\n    // Create a grid indicating all nodes are undiscovered\n    const discoveredMap = [];\n    for (let i = 0; i < grid.length; i++) {\n        const arr = [];\n        for (let j = 0; j < grid[i].length; j++) {\n            arr.push(false);\n        }\n\n        discoveredMap.push(arr);\n    }\n\n    return discoveredMap;\n}\n\n\nfunction initTotalWeightGridWithInfinity(grid) {\n    const totalWeights = [];\n\n    for (let i = 0; i < grid.length; i++) {\n        const arr = [];\n        for (let j = 0; j < grid[i].length; j++) {\n            arr.push(Infinity);\n        }\n\n        totalWeights.push(arr);\n    }\n\n    return totalWeights;\n}\n\n// This is a Priority Queue that utilizes a Min Heap\nclass PriorityQueue {\n    // data's elements have the structure of [weight, row, col]\n    constructor(/*grid*/) {\n        this.data = [];\n\n\n        /*for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                this.data.push(new QueueNode(Infinity, i, j));\n            }\n        }*/\n\n        // Heapsort - not needed for dijkstra's\n        /*for (let i = Math.ceil(this.data.length / 2) - 1; i >= 0; i--) {\n            this.fixDown(i);\n        }*/\n    }\n\n\n    empty() {\n        return this.data.length === 0;\n    }\n\n\n    top() {\n        return this.data[0];\n    }\n\n\n    push(row, col, weight) {\n        this.data.push(new Node(row, col, weight));\n        this.fixUp(this.data.length - 1);\n    }\n\n\n    pop() {\n        this.data[0] = this.data[this.data.length - 1];\n        this.data.pop();\n        this.fixDown(0);\n    }\n\n\n    // Private method\n    fixUp(n) {\n        // if (n === 0)\n        //     return;\n\n        let parentIndex = Math.ceil(n / 2) - 1;\n\n        ////// This is a recursive definition\n        // if (this.data[n].weight < this.data[parentIndex].weight) {\n        //     const temp = this.data[n];\n        //     this.data[n] = this.data[parentIndex];\n        //     this.data[parentIndex] = temp;\n\n        //     return this.fixUp(parentIndex);\n        // }\n        // else\n        //     return;\n\n        // Iterative definition\n        while (n !== 0 && this.data[n].weight < this.data[parentIndex].weight) {\n            const temp = this.data[n];\n            this.data[n] = this.data[parentIndex];\n            this.data[parentIndex] = temp;\n\n            n = parentIndex;\n            parentIndex = Math.ceil(n / 2) - 1;\n        }\n    }\n\n\n    // Private method\n    fixDown(n) {\n        if ((2 * n) + 1 >= this.data.length)\n            return;\n\n        // If the node has 2 children and must be rearranged\n        if ((2 * n) + 2 < this.data.length && this.data[n].weight >\n            Math.min(this.data[(2 * n) + 1].weight, this.data[(2 * n) + 2].weight)) {\n\n            const temp = this.data[n];\n\n            if (this.data[(2 * n) + 1].weight < this.data[(2 * n) + 2].weight) {\n                this.data[n] = this.data[(2 * n) + 1];\n                this.data[(2 * n) + 1] = temp;\n\n                return this.fixDown((2 * n) + 1);\n            }\n            else {\n                this.data[n] = this.data[(2 * n) + 2];\n                this.data[(2 * n) + 2] = temp;\n\n                return this.fixDown((2 * n) + 2);\n            }\n        }\n        // If the node only has 1 child and must be rearranged\n        else if ((2 * n) + 1 < this.data.length &&\n            this.data[n].weight > this.data[(2 * n) + 1].weight) {\n\n            const temp = this.data[n];\n            this.data[n] = this.data[(2 * n) + 1];\n            this.data[(2 * n) + 1] = temp;\n\n            return this.fixDown((2 * n) + 1);\n        }\n    }\n\n}\n\nclass Node {\n    constructor(row, col, weight) {\n        this.row = row;\n        this.col = col;\n        this.weight = weight;\n    }\n}\n\n\n\n\n\n\nexport { backtrackPath, initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue };\n\n","import { initDiscoveredGrid } from './CommonFunctions';\n\n// Determins the path between the 2 points using either BFS or DFS\n\nfunction traditionalSolve(oldGrid, homeCoords, destCoords, useBFS) {\n    const grid = oldGrid.slice();\n\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap and set the Home Point as discovered\n    const discoveredMap = initDiscoveredGrid(grid);\n    discoveredMap[homeCoords[0]][homeCoords[1]] = true;\n\n    // Create dequeue and add the Home Node\n    const deque = [];\n    deque.push(new Coordinate(homeCoords[0], homeCoords[1])); // Row, Col\n\n    // Continue while there are still nodes in the deque\n    while (deque.length !== 0) {\n        let nextNode;\n\n        // Get the next node based on BFS/DFS\n        if (useBFS) // Using a queue structure\n            nextNode = deque.shift();\n        else // Using a stack structure\n            nextNode = deque.pop();\n\n        nodesVisitedInOrder.push(nextNode);\n\n        // We do not need to check since the algorithm stops when the destination is a neighbor\n        // // Check if this is the destination\n        // if (nextNode.row === destCoords[0] && nextNode.col === destCoords[1])\n        //     break;\n\n        if (addNeighbors(grid, deque, nextNode, discoveredMap, destCoords)) {\n            nodesVisitedInOrder.push(new Coordinate(destCoords[0], destCoords[1]));\n            break;\n        }\n    }\n\n    return [nodesVisitedInOrder, grid];\n}\n\n\n// Returns true if the destination has been found\nfunction addNeighbors(grid, deque, node, discoveredMap, destCoords) {\n    // Add to the deque if it is within the bounds, has not been discovered, and is not a wall\n\n    // Right\n    if (node.col < grid[0].length - 1 && !discoveredMap[node.row][node.col + 1] && !grid[node.row][node.col + 1].isWall) {\n        grid[node.row][node.col + 1].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row][node.col + 1] = true;\n\n        if (node.row === destCoords[0] && node.col + 1 === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row, node.col + 1));\n        //pq.push(node.row, node.col + 1, grid[node.row][node.col + 1].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Above\n    if (node.row > 0 && !discoveredMap[node.row - 1][node.col] && !grid[node.row - 1][node.col].isWall) {\n        grid[node.row - 1][node.col].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row - 1][node.col] = true;\n\n        if (node.row - 1 === destCoords[0] && node.col === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row - 1, node.col));\n        //pq.push(node.row - 1, node.col, grid[node.row - 1][node.col].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Left\n    if (node.col > 0 && !discoveredMap[node.row][node.col - 1] && !grid[node.row][node.col - 1].isWall) {\n        grid[node.row][node.col - 1].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row][node.col - 1] = true;\n\n        if (node.row === destCoords[0] && node.col - 1 === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row, node.col - 1));\n        //pq.push(node.row, node.col - 1, grid[node.row][node.col - 1].weight + node.weight, [node.row, node.col]);\n    }\n\n    // Below\n    if (node.row < grid.length - 1 && !discoveredMap[node.row + 1][node.col] && !grid[node.row + 1][node.col].isWall) {\n        grid[node.row + 1][node.col].parentNode = grid[node.row][node.col];\n        discoveredMap[node.row + 1][node.col] = true;\n\n        if (node.row + 1 === destCoords[0] && node.col === destCoords[1])\n            return true;\n\n        deque.push(new Coordinate(node.row + 1, node.col));\n        //pq.push(node.row + 1, node.col, grid[node.row + 1][node.col].weight + node.weight, [node.row, node.col]);\n    }\n\n    return false;\n\n}\n\n\nclass Coordinate {\n    constructor(row, col) {\n        this.row = row;\n        this.col = col;\n    }\n}\n\n\n\nexport default traditionalSolve;\n","import { initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue } from './CommonFunctions';\n\n// Determines the shortest path using Djikstra's algorithm\n\n// homeCoords and destCoords are in the format of [row, col]\nfunction dijkstraSolve(origGrid, homeCoords, destCoords) {\n    const grid = origGrid.slice();\n\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap\n    const discoveredMap = initDiscoveredGrid(grid);\n\n    const totalWeights = initTotalWeightGridWithInfinity(grid);\n    totalWeights[homeCoords[0]][homeCoords[1]] = 0;\n\n    // Create PQ and add the Home Node\n    let pq = new PriorityQueue();\n    pq.push(homeCoords[0], homeCoords[1], 0); // Row, Col, Weight\n\n    // Continue while there are still nodes in the PQ\n    while (!pq.empty()) {\n        const closestNode = pq.top();\n        pq.pop();\n\n        // Mark the node as discovered - we can guarantee that there is no shorter path\n        if (!discoveredMap[closestNode.row][closestNode.col]) {\n            nodesVisitedInOrder.push(closestNode);\n            discoveredMap[closestNode.row][closestNode.col] = true;\n        }\n\n        // Check if this is the destination\n        if (closestNode.row === destCoords[0] && closestNode.col === destCoords[1])\n            break;\n\n        //addNeighbors(grid, pq, closestNode, totalWeights/*, discoveredMap*/);\n        // Add neighbors\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col + 1);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row - 1, closestNode.col);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col - 1);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row + 1, closestNode.col);\n    }\n\n    return [nodesVisitedInOrder, grid];\n}\n\n\nfunction addNodeToPQ(grid, totalWeights, pq, parent, row, col) {\n    // Return if out of bounds or is a wall\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length || grid[row][col].isWall)\n        return;\n\n    const prospectiveWeight = totalWeights[parent.row][parent.col] + grid[row][col].weight;\n    // Update if the prospective weight is better than our current weight\n    if (prospectiveWeight < totalWeights[row][col]) {\n        pq.push(row, col, prospectiveWeight);\n\n        totalWeights[row][col] = prospectiveWeight;\n        grid[row][col].parentNode = grid[parent.row][parent.col];\n    }\n}\n\n\n\nexport default dijkstraSolve;\n\n\n","import { initDiscoveredGrid, initTotalWeightGridWithInfinity, PriorityQueue } from './CommonFunctions';\n\n// Determines the shortest path using the A-Star algorithm\n\n// homeCoords and destCoords are in the format of [row, col]\nfunction aStarSolve(origGrid, homeCoords, destCoords) {\n    const grid = origGrid.slice();\n\n    // Must contain structures using <row> and <col>\n    const nodesVisitedInOrder = [];\n\n    // Create discoveredMap\n    const discoveredMap = initDiscoveredGrid(grid);\n\n    const totalWeights = initTotalWeightGridWithInfinity(grid);\n    totalWeights[homeCoords[0]][homeCoords[1]] = getWeightHeuristic(homeCoords[0], homeCoords[1], destCoords);\n\n    // Create PQ and add the Home Node\n    let pq = new PriorityQueue();\n    pq.push(homeCoords[0], homeCoords[1], getWeightHeuristic(homeCoords[0], homeCoords[1], destCoords)); // Row, Col, Weight\n\n    // Continue while there are still nodes in the PQ\n    while (!pq.empty()) {\n        const closestNode = pq.top();\n        pq.pop();\n\n        // Mark the node as discovered - we can guarantee that there is no shorter path\n        if (!discoveredMap[closestNode.row][closestNode.col]) {\n            nodesVisitedInOrder.push(closestNode);\n            discoveredMap[closestNode.row][closestNode.col] = true;\n        }\n\n        // Check if this is the destination\n        if (closestNode.row === destCoords[0] && closestNode.col === destCoords[1])\n            break;\n\n        //addNeighbors(grid, pq, closestNode, totalWeights/*, discoveredMap*/);\n        // Add neighbors\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col + 1, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row - 1, closestNode.col, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row, closestNode.col - 1, destCoords);\n        addNodeToPQ(grid, totalWeights, pq, closestNode, closestNode.row + 1, closestNode.col, destCoords);\n    }\n\n    return [nodesVisitedInOrder, grid];\n}\n\n\nfunction addNodeToPQ(grid, totalWeights, pq, parent, row, col, destCoords) {\n    // Return if out of bounds or is a wall\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length || grid[row][col].isWall)\n        return;\n\n    let prospectiveWeight = totalWeights[parent.row][parent.col] + grid[row][col].weight;\n    prospectiveWeight += getWeightHeuristic(row, col, destCoords) - getWeightHeuristic(parent.row, parent.col, destCoords);\n\n    // Update if the prospective weight is better than our current weight\n    if (prospectiveWeight < totalWeights[row][col]) {\n        pq.push(row, col, prospectiveWeight);\n\n        totalWeights[row][col] = prospectiveWeight;\n        grid[row][col].parentNode = grid[parent.row][parent.col];\n    }\n}\n\n\nfunction getWeightHeuristic(row, col, destCoords) {\n    //return Math.abs(row - destCoords[0]) + Math.abs(col - destCoords[1]);\n    const dy = row - destCoords[0];\n    const dx = col - destCoords[1];\n    return Math.sqrt((dx * dx) + (dy * dy));\n}\n\n\nexport default aStarSolve;\n","import React, { Component } from 'react';\nimport Node from './Node';\nimport Buttons from './Buttons';\n\nimport traditionalSolve from '../Algorithms/BFSandDFS';\nimport dijkstraSolve from '../Algorithms/Dijkstra';\nimport aStarSolve from '../Algorithms/AStar';\nimport { backtrackPath } from '../Algorithms/CommonFunctions';\nimport './Styles/Grid.css';\n\n\n// pseudo-enum\n// const PathfindingMethod = {\n//     DIJKSTRA: 1\n// };\n\n\nclass Grid extends Component {\n\n    constructor() {\n        super();\n        this.state = {\n            grid: [],\n            weightMultiplier: 15,\n            mouseIsPressed: false,\n            clickSettingOn: false,\n            clickSettingIsWall: true,\n            movingEndpoints: false, // Only set on mouse down\n            movingHome: false,\n            homeCoords: [10, 10],\n            destCoords: [10, 44],\n            isSolving: false,\n            isSolved: false,\n            lastAlgo: null\n        };\n    }\n\n\n    componentDidMount() {\n        const numRows = 21;\n        const numCols = 55;\n\n        const initGrid = getStarterGrid(numRows, numCols, this.state.homeCoords, this.state.destCoords);\n        this.setState({ grid: initGrid });\n    }\n\n\n    handleMouseDown(row, col) {\n        // Return if the path is currently being solved\n        if (this.state.isSolving)// || this.state.isSolved)\n            return;\n\n        // Check if we are moving either the Home point or the Destination\n        if (this.state.grid[row][col].isHome) {\n            this.setState({ mouseIsPressed: true, movingEndpoints: true, movingHome: true });\n            return;\n        }\n        else if (this.state.grid[row][col].isDest) {\n            this.setState({ mouseIsPressed: true, movingEndpoints: true, movingHome: false });\n            return;\n        }\n        // else if (this.state.isSolved) {\n        //     return;\n        // }\n\n        // Get the new click settings and toggle\n        // The new setting is the opposite of whatever the current click mode property is for the clicked node\n        let newClickSetting;\n        if (this.state.clickSettingIsWall)\n            newClickSetting = !this.state.grid[row][col].isWall;\n        else\n            newClickSetting = this.state.grid[row][col].weight === 1;\n\n\n        const updatedGrid = toggleNodeType(this.state.grid, row, col, newClickSetting, this.state.clickSettingIsWall, this.state.weightMultiplier);\n\n        if (this.state.isSolved) {\n            this.setState({ grid: updatedGrid, mouseIsPressed: true, clickSettingOn: newClickSetting, movingEndpoints: false }, function () {\n                this.findPath(this.state.lastAlgo, true);\n            });\n        }\n        else {\n            this.setState({ grid: updatedGrid, mouseIsPressed: true, clickSettingOn: newClickSetting, movingEndpoints: false });\n        }\n    }\n\n\n    handleMouseEnter(row, col) {\n        // Ignore if we are not dragging or if the path is being solved\n        if (!this.state.mouseIsPressed) {// || this.state.isSolving) {\n            return;\n        }\n        // Check if we are moving either the Home point or the Destination\n        else if (this.state.movingEndpoints) {\n            let updatedCoords;\n            let updatedGrid;\n\n            if (this.state.movingHome) {\n                [updatedGrid, updatedCoords] = changeEndpointLocation(this.state.grid, this.state.homeCoords, this.state.destCoords, row, col, true);\n\n                if (!this.state.isSolved) {\n                    this.setState({ grid: updatedGrid, homeCoords: updatedCoords });\n                }\n                else {\n                    this.setState({ grid: updatedGrid, homeCoords: updatedCoords }, function () {\n                        this.findPath(this.state.lastAlgo, true);\n                    });\n                }\n            }\n            else {\n                [updatedGrid, updatedCoords] = changeEndpointLocation(this.state.grid, this.state.homeCoords, this.state.destCoords, row, col, false);\n\n                if (!this.state.isSolved) {\n                    this.setState({ grid: updatedGrid, destCoords: updatedCoords });\n                }\n                else {\n                    this.setState({ grid: updatedGrid, destCoords: updatedCoords }, function () {\n                        this.findPath(this.state.lastAlgo, true);\n                    });\n                }\n            }\n\n            return;\n        }\n        // Make sure we don't turn an endpoint into a wall\n        else if (this.state.grid[row][col].isHome || this.state.grid[row][col].isDest) {\n            return;\n        }\n\n        const updatedGrid = toggleNodeType(this.state.grid, row, col, this.state.clickSettingOn, this.state.clickSettingIsWall, this.state.weightMultiplier);\n        if (!this.state.isSolved) {\n            this.setState({ grid: updatedGrid });\n        }\n        else {\n            this.setState({ grid: updatedGrid }, function () {\n                this.findPath(this.state.lastAlgo, true);\n            });\n        }\n    }\n\n\n    handleMouseUp() {\n        this.setState({ mouseIsPressed: false });\n    }\n\n\n    // 0 - BFS\n    // 1 - DFS\n    // 2 - Dijkstra\n    // 3 - A-Star\n    findPath(pathfindingMethod, isRedraw = false) {\n        if (this.state.isSolving)\n            return;\n\n        this.clearGrid(0);\n        if (!isRedraw) {\n            this.setState({ isSolving: true, lastAlgo: pathfindingMethod });\n        }\n\n        let nodesDiscoveredInOrder;\n\n        document.getElementById('weight-warning').style.visibility = (pathfindingMethod <= 1) ? 'visible' : 'hidden';\n\n        const starterGrid = this.state.grid;\n        let gridWithParents;\n\n        // If the destination is a wall, temporarily remove it\n        let destIsWall = false;\n        if (starterGrid[this.state.destCoords[0]][this.state.destCoords[1]].isWall) {\n            starterGrid[this.state.destCoords[0]][this.state.destCoords[1]].isWall = false;\n            destIsWall = true;\n        }\n\n        switch (pathfindingMethod) {\n            case 0:\n                [nodesDiscoveredInOrder, gridWithParents] = traditionalSolve(starterGrid, this.state.homeCoords, this.state.destCoords, true);\n                break;\n\n            case 1:\n                [nodesDiscoveredInOrder, gridWithParents] = traditionalSolve(starterGrid, this.state.homeCoords, this.state.destCoords, false);\n                break;\n\n            case 2:\n                [nodesDiscoveredInOrder, gridWithParents] = dijkstraSolve(starterGrid, this.state.homeCoords, this.state.destCoords);\n                break;\n\n            case 3:\n                [nodesDiscoveredInOrder, gridWithParents] = aStarSolve(starterGrid, this.state.homeCoords, this.state.destCoords);\n                break;\n\n            default:\n                return;\n        }\n\n        // Remake the destination to a wall if that's how it was initially\n        if (destIsWall) {\n            gridWithParents[this.state.destCoords[0]][this.state.destCoords[1]].isWall = true;\n        }\n\n        // Set the grid with the calculated parents\n        this.setState({ grid: gridWithParents });\n\n\n        if (isRedraw) {\n            this.showRedraw(nodesDiscoveredInOrder);\n        }\n        else {\n            this.animate(nodesDiscoveredInOrder);\n        }\n\n    }\n\n\n    animate(nodesDiscoveredInOrder) {\n        for (let i = 0; i < nodesDiscoveredInOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesDiscoveredInOrder[i];\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-discovered\");\n            }, 6 * i);\n        }\n\n        setTimeout(() => {\n            this.animatePath();\n        }, 6 * nodesDiscoveredInOrder.length);\n    }\n\n\n    animatePath() {\n        const path = backtrackPath(this.state.grid[this.state.destCoords[0]][this.state.destCoords[1]]);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            setTimeout(() => {\n                const node = path[i];\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-path\");\n            }, 30 * (path.length - 1 - i));\n        }\n\n        setTimeout(() => {\n            this.setState({ isSolving: false, isSolved: true });\n        }, 30 * path.length);\n    }\n\n\n    showRedraw(nodesDiscoveredInOrder) {\n        for (let i = 0; i < nodesDiscoveredInOrder.length; i++) {\n            const node = nodesDiscoveredInOrder[i];\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-discovered-redrawn\");\n        }\n\n        this.showPathRedrawn();\n    }\n\n\n    showPathRedrawn() {\n        const path = backtrackPath(this.state.grid[this.state.destCoords[0]][this.state.destCoords[1]]);\n\n        for (let i = path.length - 1; i >= 0; i--) {\n            const node = path[i];\n            document.getElementById(`node-${node.row}-${node.col}`).classList.add(\"node-path\");\n        }\n    }\n\n\n    // type parameter:\n    // 0 & ALWAYS - Unvisit all nodes and erase path\n    // 1 - Clear Walls\n    // 2 - Clear Weights\n    // 3 - Clear All\n    clearGrid(type, isButtonAction = false) {\n        if (this.state.isSolving)\n            return;\n\n        const clearedGrid = clearGrid(this.state.grid, type);\n        this.setState({ grid: clearedGrid });\n\n        // Reset the lastAlgo if we are clearing by button click\n        if (isButtonAction) {\n            this.setState({ isSolved: false, lastAlgo: null });\n        }\n    }\n\n\n    render() {\n        const { grid } = this.state;\n        const { openIntro } = this.props;\n\n        return (\n            <>\n                <Buttons\n                    openIntro={openIntro}\n\n                    showBFS={() => this.findPath(0)}\n                    showDFS={() => this.findPath(1)}\n                    showDijkstra={() => this.findPath(2)}\n                    showAStar={() => this.findPath(3)}\n\n                    clearPath={() => this.clearGrid(0, true)}\n                    clearWalls={() => this.clearGrid(1, true)}\n                    clearWeights={() => this.clearGrid(2, true)}\n                    clearAll={() => this.clearGrid(3, true)}\n\n                    toggleClick={() => this.setState({ clickSettingIsWall: !this.state.clickSettingIsWall })}\n                ></Buttons>\n\n                <div id=\"weight-warning\" style={{ color: 'red', visibility: 'hidden', marginBottom: '5px', zIndex: '10px' }}>This Algorithm ignores nodes' weights</div>\n\n                <div className=\"gridContainer\">\n                    <div className=\"grid\" onMouseLeave={() => this.handleMouseUp()} onMouseUp={() => this.handleMouseUp()}>\n                        {grid.map((row, col) => {\n                            return (\n                                <div className=\"row\" key={col}>\n                                    {row.map((node, nodeIdx) => {\n                                        const { row, col, isWall, weight, isHome, isDest } = node;\n\n                                        return (\n                                            <Node key={nodeIdx}\n                                                row={row}\n                                                col={col}\n                                                isWall={isWall}\n                                                isWeighted={weight !== 1}\n                                                isHome={isHome}\n                                                isDest={isDest}\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                            ></Node>\n                                        );\n                                    })}\n                                </div>\n                            );\n                        })}\n                    </div>\n                </div>\n\n            </>\n        );\n    }\n}\n\n\nconst getStarterGrid = (numRows, numCols, homeCoords, destCoords) => {\n    const grid = [];\n\n    for (let i = 0; i < numRows; i++) {\n        const nodeRow = [];\n        for (let j = 0; j < numCols; j++) {\n            nodeRow.push(constructNode(i, j, homeCoords, destCoords));\n        }\n\n        grid.push(nodeRow);\n    }\n\n    return grid;\n}\n\n\nconst constructNode = (row, col, homeCoords, destCoords) => {\n    return {\n        row,\n        col,\n        weight: 1,\n        isWall: false,\n        isHome: row === homeCoords[0] && col === homeCoords[1],\n        isDest: row === destCoords[0] && col === destCoords[1],\n        parentNode: null\n    };\n}\n\n\nconst toggleNodeType = (oldGrid, row, col, clickSettingOn, clickSettingIsWall, weightMultiplier) => {\n    const newGrid = oldGrid.slice();\n\n    if (clickSettingIsWall) {\n        newGrid[row][col].isWall = clickSettingOn;\n    }\n    else {\n        newGrid[row][col].weight = clickSettingOn ? weightMultiplier : 1;\n    }\n\n    return newGrid;\n}\n\n\nconst changeEndpointLocation = (oldGrid, homeCoords, destCoords, row, col, isHome) => {\n    // If isHome is true, we are moving the home node\n    // Otherwise we are moving the destination node\n\n    const newGrid = oldGrid.slice();\n\n    // Make sure that the home and destination coordinates aren't the same\n    if (isHome && !(row === destCoords[0] && col === destCoords[1])) {\n        newGrid[homeCoords[0]][homeCoords[1]].isHome = false;\n        newGrid[row][col].isHome = true;\n    }\n    else if (!isHome && !(row === homeCoords[0] && col === homeCoords[1])) {\n        newGrid[destCoords[0]][destCoords[1]].isDest = false;\n        newGrid[row][col].isDest = true;\n    }\n    else { // Return if they overlap\n        return [newGrid, isHome ? homeCoords : destCoords];\n    }\n\n    return [newGrid, [row, col]];\n}\n\n\n// type parameter:\n// ALWAYS - Unvisit all nodes and erase path\n//      ALWAYS - Reset starting grid weights -- ignore\n// 1 - Clear Walls\n// 2 - Clear Weightsw\n// 3 - Clear All\nconst clearGrid = (oldGrid, type) => {\n    const newGrid = oldGrid.slice();\n\n    // Unvisit all nodes\n    const visitedNodes = document.querySelectorAll(\".node-discovered\");\n    [].forEach.call(visitedNodes, function (el) {\n        el.classList.remove(\"node-discovered\");\n    });\n\n    const visitedNodesRedrawn = document.querySelectorAll(\".node-discovered-redrawn\");\n    [].forEach.call(visitedNodesRedrawn, function (el) {\n        el.classList.remove(\"node-discovered-redrawn\");\n    });\n\n\n    // Erase the path\n    const pathNodes = document.querySelectorAll(\".node-path\");\n    [].forEach.call(pathNodes, function (el) {\n        el.classList.remove(\"node-path\");\n    });\n\n\n\n    // Iterate through the grid\n    for (let i = 0; i < newGrid.length; i++) {\n        for (let j = 0; j < newGrid[i].length; j++) {\n\n            // Reset parents\n            newGrid[i][j].parentNode = null;\n\n            if (type === 1 || type === 3) // Clear walls\n                newGrid[i][j].isWall = false;\n            if (type === 2 || type === 3) // Clear Weights\n                newGrid[i][j].weight = 1;\n\n        }\n    }\n\n\n    return newGrid;\n}\n\n\n\nexport default Grid;\n","import React from 'react';\nimport './Styles/Introduction.css';\n\nfunction Introduction({ closeIntro }) {\n    return (\n        <div className=\"intro-container\">\n            <div>\n                <button type=\"button\" className=\"close\" data-dismiss=\"alert\" aria-label=\"Close\" onClick={closeIntro}>\n                    <span aria-hidden=\"true\">&times;</span>\n                </button>\n            </div>\n            <div className=\"intro\">\n\n\n                <h1>Introduction : </h1>\n                <p> Welcome to <b>NavPath</b> by Viroshan Narayan! </p>\n                <p>Here, you can see how different pathfinding algorithms work, all with your own eyes!</p>\n                <p>Here are a few things to get you started:</p>\n\n                <div>\n                    <ol className=\"instruction-set\">\n                        <li>Click and drag the home and destination points to move them.</li>\n                        <li>Click and drag on empty nodes to make them walls or weighted nodes.<br /> This setting is determined by the toggle at the top of the page.\n                            <ul>\n                                <li>Walls cannot be passed through</li>\n                                <li>Weighted nodes are harder to move through</li>\n                                <li>Not all algorithms are affected by weights</li>\n                            </ul>\n                        </li>\n                        <li>Find the path from the home point to the destination using any of the<br /> following algorithms:\n                            <ul>\n                                <li><b>Breadth-First Search (BFS):</b> an <b>unweighted</b> algorithm that<br />&emsp; guarantees optimality</li>\n                                <li><b>Depth-First Search (DFS):</b> a very inefficient, <b>unweighted</b><br />&emsp; algorithm</li>\n                                <li><b>Dijkstra's Algorithm:</b> a <b>weighted</b> algorithm that<br />&emsp; guarantees optimality</li>\n                                <li><b>A*:</b> a smarter version of Dijkstra's Algorithm</li>\n                            </ul>\n                        </li>\n                        <li>Clear the displayed path, walls, or weights using the \"Clear\" dropdown<br />&emsp; at the top of the page</li>\n                    </ol>\n                </div>\n                <p>If you'd like to, you can check out the source code for this site at my <a href=\"https://github.com/vironaray/navpath\" target=\"_blank\" rel=\"noreferrer\">github</a>.</p>\n                <p>Now that you're up to speed, <b>LET'S FIND SOME PATHS!!!</b></p>\n            </div>\n        </div>\n    );\n}\n\n\nexport default Introduction;\n","import './App.css';\n\nimport { useState } from 'react';\nimport Grid from './Components/Grid';\nimport Introduction from './Components/Introduction';\n\nfunction App() {\n  const [showIntro, setIntroVisibility] = useState(true);\n\n  return (\n    <div className=\"App\">\n      {showIntro &&\n        <Introduction closeIntro={() => setIntroVisibility(false)} />\n      }\n      <Grid openIntro={() => setIntroVisibility(!showIntro)} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}